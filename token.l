%{
#include <stdio.h>
#include <string.h>
#include "tokenizer.tab.h" // This file will be generated by Bison (parser.y)

// Global variables and utility functions from your provided C code
#define MAX_TOKENS 2048
#define MAX_VALUE_LEN 128

typedef struct {
    char type[32];
    char value[MAX_VALUE_LEN];
    int line;
} Token;

Token tokens[MAX_TOKENS];
int token_count = 0;

typedef struct {
    char name[MAX_VALUE_LEN];
    char value[MAX_VALUE_LEN];
    char type[32];
    int line;
} Variable;

Variable variables[MAX_TOKENS];
int variable_count = 0;

void add_token(const char* type, const char* value, int line) {
    if (token_count < MAX_TOKENS) {
        strncpy(tokens[token_count].type, type, sizeof(tokens[token_count].type)-1);
        tokens[token_count].type[sizeof(tokens[token_count].type)-1] = '\0';
        strncpy(tokens[token_count].value, value, sizeof(tokens[token_count].value)-1);
        tokens[token_count].value[sizeof(tokens[token_count].value)-1] = '\0';
        tokens[token_count].line = line;
        token_count++;
    }
}

// Note: add_variable is typically handled by the parser after type checking,
// but keeping it here as per your original request's C code.
void add_variable(const char* name, const char* value, const char* type, int line) {
    if (variable_count < MAX_TOKENS) {
        strncpy(variables[variable_count].name, name, sizeof(variables[variable_count].name)-1);
        variables[variable_count].name[sizeof(variables[variable_count].name)-1] = '\0';
        strncpy(variables[variable_count].value, value, sizeof(variables[variable_count].value)-1);
        variables[variable_count].value[sizeof(variables[variable_count].value)-1] = '\0';
        strncpy(variables[variable_count].type, type, sizeof(variables[variable_count].type)-1);
        variables[variable_count].type[sizeof(variables[variable_count].type)-1] = '\0';
        variables[variable_count].line = line;
        variable_count++;
    }
}

// Line number tracking
int yyline = 1;

// Forward declaration for yyerror from Bison
void yyerror(const char *s);

%}

%%

[ \t]+                      ; /* Ignore whitespace */
\n                          { yyline++; } /* Increment line number on newline */
"//".* ; /* Ignore single-line comments */

"if"                        { add_token("IF", yytext, yyline); return IF_TOKEN; }
"else"                      { add_token("ELSE", yytext, yyline); return ELSE_TOKEN; }
"elseif"                    { add_token("ELSEIF", yytext, yyline); return ELSEIF_TOKEN; } // Added ELSEIF
"while"                     { add_token("WHILE", yytext, yyline); return WHILE_TOKEN; }
"for"                       { add_token("FOR", yytext, yyline); return FOR_TOKEN; }
"return"                    { add_token("RETURN", yytext, yyline); return RETURN_TOKEN; }
"int"                       { add_token("INT", yytext, yyline); return INT_TOKEN; }
"float"                     { add_token("FLOAT", yytext, yyline); return FLOAT_TOKEN; }
"bool"                      { add_token("BOOL", yytext, yyline); return BOOL_TOKEN; }
"string"                    { add_token("STRING", yytext, yyline); return STRING_TOKEN; }
"void"                      { add_token("VOID", yytext, yyline); return VOID_TOKEN; } // Ensure VOID returns a token
"var"                       { add_token("VAR", yytext, yyline); sscanf(yytext, "%s", yylval.str); return VAR_TOKEN; }
"func"                      { add_token("FUNC", yytext, yyline); return FUNC_TOKEN; }
"main"                      { add_token("MAIN", yytext, yyline); return MAIN_TOKEN; }
"program"                   { add_token("PROGRAM", yytext, yyline); return PROGRAM_TOKEN; }
"print"                     { add_token("PRINT", yytext, yyline); return PRINT_TOKEN; }
"read"                      { add_token("READ", yytext, yyline); return READ_TOKEN; } // Added READ
"to"                        { add_token("TO", yytext, yyline); return TO_TOKEN; }


"=="                        { add_token("EQ", yytext, yyline); return EQ_TOKEN; }
"!="                        { add_token("NEQ", yytext, yyline); return NEQ_TOKEN; }
"<="                        { add_token("LE", yytext, yyline); return LE_TOKEN; }
">="                        { add_token("GE", yytext, yyline); return GE_TOKEN; }
"<"                         { add_token("LT", yytext, yyline); return LT_TOKEN; }
">"                         { add_token("GT", yytext, yyline); return GT_TOKEN; }
"="                         { add_token("EQUALS", yytext, yyline); return EQUALS_TOKEN; }
"+"                         { add_token("PLUS", yytext, yyline); return PLUS_TOKEN; }
"-"                         { add_token("MINUS", yytext, yyline); return MINUS_TOKEN; }
"*"                         { add_token("MUL", yytext, yyline); return MUL_TOKEN; }
"/"                         { add_token("DIV", yytext, yyline); return DIV_TOKEN; }
"%"                         { add_token("MOD", yytext, yyline); return MOD_TOKEN; }
"("                         { add_token("LPAREN", yytext, yyline); return LPAREN_TOKEN; }
")"                         { add_token("RPAREN", yytext, yyline); return RPAREN_TOKEN; }
"{"                         { add_token("LBRACE", yytext, yyline); return LBRACE_TOKEN; }
"}"                         { add_token("RBRACE", yytext, yyline); return RBRACE_TOKEN; }
":"                         { add_token("COLON", yytext, yyline); return COLON_TOKEN; }
";"                         { add_token("SEMICOLON", yytext, yyline); return SEMICOLON_TOKEN; }
","                         { add_token("COMMA", yytext, yyline); return COMMA_TOKEN; }

"&&"                        { add_token("AND", yytext, yyline); return AND_TOKEN; }
"||"                        { add_token("OR", yytext, yyline); return OR_TOKEN; }
"!"                         { add_token("NOT", yytext, yyline); return NOT_TOKEN; }

(true|false)                { add_token("BOOL_LITERAL", yytext, yyline);
                              strncpy(yylval.str, yytext, sizeof(yylval.str)-1);
                              yylval.str[sizeof(yylval.str)-1] = '\0';
                              return BOOL_LITERAL_TOKEN; }
[0-9]+                      { add_token("NUMBER", yytext, yyline);
                              yylval.number = atoi(yytext); return NUMBER_TOKEN; }
[0-9]+\.[0-9]+              { add_token("FLOAT_LITERAL", yytext, yyline);
                              yylval.fval = atof(yytext); return FLOAT_LITERAL_TOKEN; }
\"[^\"]*\"                  { add_token("STRING_LITERAL", yytext, yyline);
                              strncpy(yylval.str, yytext, sizeof(yylval.str)-1);
                              yylval.str[sizeof(yylval.str)-1] = '\0';
                              return STRING_LITERAL_TOKEN; }
[a-zA-Z_][a-zA-Z0-9_]* { add_token("IDENTIFIER", yytext, yyline);
                              strncpy(yylval.str, yytext, sizeof(yylval.str)-1);
                              yylval.str[sizeof(yylval.str)-1] = '\0';
                              return IDENTIFIER_TOKEN; }

.                           { fprintf(stderr, "Caracter ilegal '%s' en la l√≠nea %d\n", yytext, yyline); }

%%

int yywrap(){
    return 1;
}