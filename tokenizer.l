%{
#include <stdio.h>
#include <string.h>
#include "parser.tab.h" // This file will be generated by Bison (parser.y)

// Line number tracking
int line_number = 1;

// Forward declaration for yyerror from Bison - ELIMINADA: no es necesaria aquí si no se llama directamente
// void yyerror(const char *s);

// Definición de MAX_VALUE_LEN para yylval.str (se mantiene por si se usa en el futuro, aunque no en esta versión simplificada)
#define MAX_VALUE_LEN 128

%}

%%

[ \t]+                      ; /* Ignore whitespace */
\n                          { line_number++; }
"//".* ; /* Ignore single-line comments */

"if"                        { return IF_TOKEN; }
"else"                      { return ELSE_TOKEN; }
"elseif"                    { return ELSEIF_TOKEN; }
"while"                     { return WHILE_TOKEN; }
"for"                       { return FOR_TOKEN; }
"return"                    { return RETURN_TOKEN; }
"int"                       { return INT_TOKEN; }
"float"                     { return FLOAT_TOKEN; }
"bool"                      { return BOOL_TOKEN; }
"string"                    { return STRING_TOKEN; }
"void"                      { return VOID_TOKEN; }
"var"                       { strncpy(yylval.str, yytext, sizeof(yylval.str)-1); yylval.str[sizeof(yylval.str)-1] = '\0'; return VAR_TOKEN; }
"func"                      { return FUNC_TOKEN; }
"main"                      { return MAIN_TOKEN; }
"program"                   { return PROGRAM_TOKEN; }
"print"                     { return PRINT_TOKEN; }
"read"                      { return READ_TOKEN; }
"to"                        { return TO_TOKEN; }


"=="                        { return EQ_TOKEN; }
"!="                        { return NEQ_TOKEN; }
"<="                        { return LE_TOKEN; }
">="                        { return GE_TOKEN; }
"<"                         { return LT_TOKEN; }
">"                         { return GT_TOKEN; }
"="                         { return EQUALS_TOKEN; }
"+"                         { return PLUS_TOKEN; }
"-"                         { return MINUS_TOKEN; }
"*"                         { return MUL_TOKEN; }
"/"                         { return DIV_TOKEN; }
"%"                         { return MOD_TOKEN; }
"("                         { return LPAREN_TOKEN; }
")"                         { return RPAREN_TOKEN; }
"{"                         { return LBRACE_TOKEN; }
"}"                         { return RBRACE_TOKEN; }
":"                         { return COLON_TOKEN; }
";"                         { return SEMICOLON_TOKEN; }
","                         { return COMMA_TOKEN; }

"&&"                        { return AND_TOKEN; }
"||"                        { return OR_TOKEN; }
"!"                         { return NOT_TOKEN; }

(true|false)                { strncpy(yylval.str, yytext, sizeof(yylval.str)-1); yylval.str[sizeof(yylval.str)-1] = '\0'; return BOOL_LITERAL_TOKEN; }
[0-9]+                      { yylval.number = atoi(yytext); return NUMBER_TOKEN; }
[0-9]+\.[0-9]+              { yylval.fval = atof(yytext); return FLOAT_LITERAL_TOKEN; }
\"[^\"]*\"                  { strncpy(yylval.str, yytext, sizeof(yylval.str)-1); yylval.str[sizeof(yylval.str)-1] = '\0'; return STRING_LITERAL_TOKEN; }
[a-zA-Z_][a-zA-Z0-9_]* { strncpy(yylval.str, yytext, sizeof(yylval.str)-1); yylval.str[sizeof(yylval.str)-1] = '\0'; return IDENTIFIER_TOKEN; }

.                           { fprintf(stderr, "Error:Caracter ilegal '%s' en la línea %d.....\n", yytext, line_number);}

%%

int yywrap(){
    return 1;
}
